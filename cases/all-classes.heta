
// Component
// Base element annotation
{
  id: <ID>,
  space: <ID>,
  class: <String>, // class of component
  title: <String>, // Human readable name of component
  notes: <String>, // any notes, supports Markdown
  tags: <String[]>, // tags for component
  aux: <Dict>, // Any user defined properties
  ...
};

''' Notes '''
sp1::cmd @Component 'Title' {
  tags: [a, b, c],
  aux: {},
  ...
};

// Record <= Component
// describes value which can change its value in time
p1 @Record {
  boundary: <Boolean>,    // if true it cannot be changed by @Process or @Reaction
  units: <UnitExpr>,      // units describing the value
  assignments: {
    [<ID>]: <MathExpr>,   // any number of key/value pairs describing value changes
    ...
  }
};

// record assignments
p1 .= <MathExpr>;         // calculated at start, uses start_ switcher
p1 := <MathExpr>;         // calculated at each time point, uses ode_ switcher
p1 [sw1]= <MathExpr>;     // calculated at sw1 switcher
p1 []= <MathExpr>;        // the same as .=

// Process <= Record 
// change record values using ODEs
pr1 @Process {
  actors: <ProcessExpr>/<Actor[]> // describes records to change
};

// correct ProcessExpr
1*A = 2*B + 3*C
A => 2B + 3C      // mark as irreversible
A <=> B + B + 3C  // mark as reversible

// TimeSwitcher <= Component
// run reassignment of records at specific time points
sw1 @TimeSwitcher {
  start: <Number>, // required, when switcher is called
  period: <Integer>, // >0, if set, the switcher will be called with period
  repeatCount: <Integer> // >=0, if set the switche will be called (repeatCount + 1) times
};

// Const <= Component
// numerical value which does not change in time
k1 @Const {
  units: <UnitExpr>,      // units describing the value
  num: <Number>,          // required, constant value
  free: <Boolean>         // if true the value is marked for fitting
};

// Compartment <= Record <= Component
// describes volumes where Species instances are located
comp1 @Compartment {
  // no specific properties
};

// Species <= Record <= Component
// describes particles in some location
s @Species {
  isAmount: <Boolean>, // 
  compartment: <ID> // required, reference to Compartment
};

// Reaction <= Process <= Record
// The same as Process, but all target references should be Species
r1 @Reaction {
  actors: <ProcessExpr>/<Reactant[]>,   // 
  modifiers: <Modifier[]>/<Id[]>        // array of references to Species
};

// ===

pmid @ReferenceDefinition {
  prefix: "https://pubmed.org",
  suffix: /
};

pow @FunctionDefinition {
  args: [x, y],
  expr: x^y
};

kDa @UnitDef {components: [
  { kind: g, multiplier: 1e3, exponent: 1},
  { kind: mole, exponent: -1}
]};

// simulations

simple_task1 @SimpleTask {
  model: sp1, // reference to space
  subtasks: [
    {saveat: [1,2,3], output_ids: [A, B, C]}
    {saveat: [4,5,6], output_ids: [C]}
  ],
  type: simulation,
  reassign: { // update constant values
    const1: 3,
    const2: 4.4
  },
  tspan: [0, 120], // time range
  solver: {
    alg: Rosenbrock23,
    reltol: 1e-6,
    abstol: 1e-12,
    maxiters: 1e7,
    dtmax: 0.1,
    tstops: [] // force calculation in time points
  },
  data: {},
  reduce: {}
};

simple_task2 @SimpleTask {
  model: sp1,
  subtasks: [
    {saveat: [4,5,6]}
  ]
};

multi_task1 @MultiTask { // unscoped
  task_vec: [simple_task1, simple_task2],
  sizes: {k1: 1, k2: 2}
};

// === fitting ===
dts1 @SimpleData {
  output_ids: [A, B, C], // depDataMarkers
  indepData: ['t'], // indepDataMarker
  t: [1, 2, 3], // indepData
  val: [ // depData
    [1, 1, 1],
    [1, 1, 1],
    [1, 1, 1]
  ],
  evid: [0, 0, 0]
}

l1 @SimpleTask {
  model: sp1,
  sizes: {}
  subtasks: [{
    data: dts1
    reduce: ln_loss2
  }],
  reduce: sum
};
l2 @SimpleTask {
  model: sp1,
  sizes: {dose: 1}
  subtasks: [{
    data: dts2
    reduce: ln_loss2
  }],
  reduce: sum
};

likelihood_sum @MultiTask {
  tasks: [l1, l2],
  reduce: sum
};

fitting_task1 @FittingTask {
  inter_task: likelihood_sum,
  fit_sizes: [k1, k2, k3],
  fitter_opt: {
    alg: LN_NELDERMEAD
  }
};

dts1 @Observation {
  kind: KineticsObservation,
  indepDataMarker: t,
  indepData: [0.1, 0.2, 0.3, 0.4, 0.5],
  depDataMarkers: [x, y, z, s],
  depData: [
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0]
  ]
};
